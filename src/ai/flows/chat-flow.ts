/**
 * @fileOverview Fluxo de chat básico para interagir com um modelo de IA, com suporte a histórico, envio de imagens e ferramentas dinâmicas.
 *
 * - basicChatFlow - Uma função que lida com uma única troca de chat, considerando o histórico, possível imagem e ferramentas.
 * - BasicChatInput - O tipo de entrada para basicChatFlow.
 * - BasicChatOutput - O tipo de retorno para basicChatFlow.
 */

import { ai } from '@/ai/genkit'; 
// Import factory functions for refactored tools
import { createPerformWebSearchTool } from '@/ai/tools/web-search-tool';
import { createKnowledgeBaseTool } from '@/ai/tools/knowledge-base-tool';
import { createCustomApiTool } from '@/ai/tools/custom-api-tool';
import { createCalendarAccessTool } from '@/ai/tools/calendar-access-tool';
import { createDatabaseAccessTool } from '@/ai/tools/database-access-tool';
// Import static tools
import { calculatorTool } from '@/ai/tools/calculator-tool';
import { codeExecutorTool } from '@/ai/tools/code-executor-tool';

import process from 'node:process';
import { ReadableStream } from 'node:stream/web'; 
import { GenerateRequest, Part, ToolRequest, ToolResponse, Tool } from '@genkit-ai/ai';
import type { MessageData } from '@/types/chat-types';
import { createLoggableFlow } from '@/lib/logger'; // Import the wrapper
import { enhancedLogger } from '@/lib/logger'; // For manual logging if needed within
import { winstonLogger } from '../../lib/winston-logger';
import { z } from 'zod';
import { ActionContext } from 'genkit';
import { AgentConfig, KnowledgeSource, RagMemoryConfig } from '../../types/agent-configs-new'; // Adjust path as needed

// Define sensitive keywords for guardrails
const SENSITIVE_KEYWORDS = ["conteúdo sensível", "excluir dados", "informação confidencial", "apagar tudo", "dados pessoais", "senha", "segredo"];

// Mapa de todas as ferramentas Genkit disponíveis na aplicação
// Stores factory functions for configurable tools and direct tool objects for static ones.
interface AppTool extends Tool {
  func: (input: any) => Promise<any>;
  inputSchema?: z.ZodSchema;
  description?: string;
  metadata?: Record<string, any>;
}

// Definir tipo explícito para tool requests
type ChatToolRequest = {
  name: string;
  input?: Record<string, unknown>;
  output?: unknown;
  ref?: string;
};

interface ToolResponsePart {
  toolRequest: ToolRequest;
  output: unknown;
}

// Interface for structured tool execution results
// Defines structured error details that tools can return or the flow can generate.
interface ErrorDetails {
  code?: string;
  message: string;
  details?: any;
}

interface ToolExecutionResult {
  name: string;
  input?: Record<string, unknown>;
  output?: any; // Holds successful output if status is 'success'
  errorDetails?: ErrorDetails; // Holds structured error if status is 'error'
  status: 'success' | 'error';
  ref?: string; // from the original toolRequest for matching
}

const allAvailableTools: Record<string, AppTool> = { 
  performWebSearch: createPerformWebSearchTool({
    apiKey: process.env.SEARCH_API_KEY
  }),
  calculator: calculatorTool(),
  knowledgeBase: createKnowledgeBaseTool({
    serviceEndpoint: process.env.KB_ENDPOINT,
    knowledgeBaseId: process.env.KB_ID || 'default'
  }),
  customApiIntegration: createCustomApiTool({
    baseUrl: process.env.API_BASE_URL
  }),
  calendarAccess: createCalendarAccessTool({
    apiKey: process.env.CALENDAR_TOKEN
  }),
  databaseAccess: createDatabaseAccessTool({
    dbConnectionString: process.env.DB_CONNECTION,
    dbType: 'postgresql' // Definindo um tipo padrão, ajuste conforme necessário
  }),
  codeExecutor: codeExecutorTool()
};

/**
 * Detailed configuration for agent tools
 */
interface ToolDetail {
  id: string;
  name: string;
  description?: string;
  enabled: boolean;
  config?: Record<string, unknown>; // Mais seguro que 'any'
}

/**
 * Information about an artifact generated by a tool.
 */
interface GeneratedArtifactInfo {
  fileName: string;
  fileType: string; // MIME type
  fileDataUri?: string; // For inline data
  fileUrl?: string;     // For external URLs
}

/**
 * Parameters for the chat flow
 */
interface ChatFlowParams {
  fileDataUri?: string;
  history?: MessageData[];
  modelName: 'geminiPro' | 'gemini15Pro' | string;
  systemPrompt?: string;
  temperature?: number;
  topK?: number;
  topP?: number;
  maxOutputTokens?: number;
  stopSequences?: string[];
  agentToolsDetails?: ToolDetail[];
  // Added for RAG
  ragMemoryConfig?: RagMemoryConfig;
  knowledgeSources?: KnowledgeSource[];
}

// Zod validation schemas
const ToolDetailSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  enabled: z.boolean(),
  config: z.record(z.unknown()).optional()
});

const ChatFlowParamsSchema = z.object({
  fileDataUri: z.string().optional(),
  history: z.array(z.unknown()).optional(),
  modelName: z.string(),
  systemPrompt: z.string().optional(),
  temperature: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  maxOutputTokens: z.number().optional(),
  stopSequences: z.array(z.string()).optional(),
  agentToolsDetails: z.array(ToolDetailSchema).optional(),
  // Added for RAG - Zod types for these would ideally come from agent-configs-new.ts if they exist
  // For now, using z.any() as a placeholder if specific Zod schemas are not readily available.
  // It's better to define these properly if possible.
  ragMemoryConfig: z.any().optional(), // Placeholder: Replace with RagMemoryConfigSchema if available
  knowledgeSources: z.array(z.any()).optional() // Placeholder: Replace with KnowledgeSourceSchema if available
});

/**
 * Entrada para o fluxo de chat básico
 */
export interface BasicChatInput extends ChatFlowParams {
  agentId?: string; // Optional agentId for logging/context
  userMessage: string;
  callbacks?: Record<string, string>; // Added for callback configuration
}

/**
 * Saída do fluxo de chat básico
 */
export interface BasicChatOutput {
  outputMessage?: string;
  stream?: ReadableStream<any>;
  toolRequests?: ChatToolRequest[];
  toolResults?: ToolExecutionResult[]; // Updated to use ToolExecutionResult
  error?: string;
  chatEvents?: Partial<{ // Using Partial as ChatEvent is defined elsewhere
    id: string;
    timestamp: Date;
    eventType: 'TOOL_CALL_PENDING' | 'TOOL_CALL' | 'TOOL_ERROR' | 'AGENT_CONTROL';
    eventTitle: string;
    eventDetails?: string;
    toolName?: string;
  }>[];
  generatedArtifact?: GeneratedArtifactInfo; // Added for artifact output
  retrievedContextForDisplay?: string; // Added for RAG context
}

// Definir tipo completo para mensagens
type ChatMessage = {
  role: 'system' | 'user' | 'model' | 'tool';
  content: Part[];
  metadata?: Record<string, unknown>;
};

// Internal function that contains the core logic
async function basicChatFlowInternal(
  input: BasicChatInput,
  flowContext: ActionContext
): Promise<BasicChatOutput> {
  const flowName = 'basicChatFlowInternal'; // For logging context
  const agentId = input.agentId || 'unknown_agent'; // For logging context
  const callbacks = input.callbacks || {}; // Extract callbacks

  // Helper function to get callback configuration
  const getCallbackConfig = (callbackName: 'beforeModel' | 'afterModel' | 'beforeTool' | 'afterTool') => {
    const logic = callbacks[`${callbackName}Logic`];
    const enabled = callbacks[`${callbackName}Enabled`] === 'true';
    if (enabled && logic) {
      winstonLogger.info(`[CallbackSim] ${callbackName} callback is enabled with logic: "${logic}"`, { agentId, flowName });
    } else if (enabled && !logic) {
      winstonLogger.info(`[CallbackSim] ${callbackName} callback is enabled but no logic is defined.`, { agentId, flowName });
    }
    return { logic, enabled };
  };

  const chatEvents: Partial<{
    id: string;
    timestamp: Date;
    eventType: 'TOOL_CALL_PENDING' | 'TOOL_CALL' | 'TOOL_ERROR' | 'AGENT_CONTROL' | 'CALLBACK_SIMULATION'; // Added CALLBACK_SIMULATION
    eventTitle: string;
    eventDetails?: string;
    toolName?: string;
    // For CALLBACK_SIMULATION, we might add specific fields like:
    callbackType?: 'beforeModel' | 'afterModel' | 'beforeTool' | 'afterTool';
    callbackAction?: string; // e.g., 'BLOCKED', 'MODIFIED', 'LOGGED'
    originalData?: string;
    modifiedData?: string;
  }>[] = [];

  try {
    const messages: ChatMessage[] = [];
    if (input.systemPrompt) {
      messages.push({ role: 'system', content: [{ text: input.systemPrompt }] });
    }
    if (input.history) {
      messages.push(...input.history.map(msg => ({
        role: msg.role as ChatMessage['role'],
        content: Array.isArray(msg.content) ?
          msg.content.map(c => typeof c === 'string' ? { text: c } : c) :
          [{ text: String(msg.content) }],
        ...('metadata' in msg && { metadata: msg.metadata as Record<string, unknown> })
      })));
    }

    // RAG Simulation Logic
    let retrievedContextForLLM = "";
    let retrievedContextForDisplay: string | undefined = undefined;
    // The AgentConfig type is used here, assuming input contains the necessary fields.
    // The caller of basicChatFlowInternal must ensure these are populated.
    const agentConfigFromInput = input as Partial<AgentConfig & ChatFlowParams>;

    if (agentConfigFromInput.ragMemoryConfig?.enabled && agentConfigFromInput.knowledgeSources && agentConfigFromInput.knowledgeSources.length > 0) {
      const simulatedRAGContextParts: string[] = [];
      agentConfigFromInput.knowledgeSources.forEach(ks => {
        if (ks.enabled) {
          simulatedRAGContextParts.push(`Source: ${ks.name}${ks.description ? ' - ' + ks.description : ''}`);
        }
      });

      if (simulatedRAGContextParts.length > 0) {
        retrievedContextForDisplay = "Simulated RAG Context:\n" + simulatedRAGContextParts.join("\n");
        retrievedContextForLLM = `\n\n[Retrieved Context from Knowledge Sources]:\n${retrievedContextForDisplay}\n\n`;
        winstonLogger.info(`Chat Flow: RAG enabled. Simulated context: ${retrievedContextForDisplay}`, { agentId });
      } else {
        winstonLogger.info("Chat Flow: RAG enabled, but no enabled knowledge sources found or they produced no context.", { agentId });
        retrievedContextForDisplay = "RAG enabled, but no relevant context found from knowledge sources.";
      }
    }

    const userMessageText = retrievedContextForLLM ? `${retrievedContextForLLM}${input.userMessage}` : input.userMessage;
    const userMessageContent: Part[] = [{ text: userMessageText }];

    // Simulate beforeModel callback
    const { logic: beforeModelLogic, enabled: beforeModelEnabled } = getCallbackConfig('beforeModel');
    if (beforeModelEnabled && beforeModelLogic) {
      winstonLogger.info(`[CallbackSim] Processing beforeModel: "${beforeModelLogic}"`, { agentId, flowName });
      if (beforeModelLogic === "BLOCK_IF_PROMPT_CONTAINS_XYZ") {
        // Check combined messages for "XYZ"
        let combinedPromptText = "";
        messages.forEach(msg => msg.content.forEach(part => { if (part.text) combinedPromptText += part.text + " ";}));
        combinedPromptText += userMessageText; // Include current user message

        if (combinedPromptText.toUpperCase().includes("XYZ")) {
          winstonLogger.warn(`[CallbackSim] Executing beforeModel: BLOCK_IF_PROMPT_CONTAINS_XYZ. Blocking request.`, { agentId, flowName });
          chatEvents.push({
            id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
            callbackType: 'beforeModel', callbackAction: 'BLOCKED',
            eventTitle: `BeforeModel: ${beforeModelLogic}`,
            eventDetails: `Request blocked because prompt contained "XYZ". Original combined prompt (part): "${combinedPromptText.substring(0, 100)}..."`
          });
          return {
            error: 'Blocked by beforeModel XYZ policy. Request not sent to LLM.',
            chatEvents,
            retrievedContextForDisplay
          };
        }
        winstonLogger.info(`[CallbackSim] beforeModel: BLOCK_IF_PROMPT_CONTAINS_XYZ did not find "XYZ". Proceeding.`, { agentId, flowName });
        // Event for just processing, if not blocked (optional, can be verbose)
        chatEvents.push({
          id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
          callbackType: 'beforeModel', callbackAction: 'PASSED_CHECK',
          eventTitle: `BeforeModel: ${beforeModelLogic}`,
          eventDetails: `Prompt did not contain "XYZ". Proceeding.`
        });
      } else if (beforeModelLogic === "ADD_SUFFIX_ABC_TO_PROMPT") {
        // Modify the last user message part for simplicity, or create a new system message
        // For this simulation, let's assume we append to the user's message text directly before it's added to messages array.
        // Since userMessageText is already constructed, we modify it here.
        // This means the userMessageContent will need to be reconstructed if it was already made.
        const suffix = " ABC_SUFFIX";
        const originalUserMessageForEvent = userMessageText; // Capture before modification for event
        // input.userMessage += suffix; // This was modifying the input object, which might be unexpected side effect for caller
                                     // Instead, we are modifying userMessageContent which is local to this flow execution.

        let newTextForUserMessageContent = "";
        let textPartFoundAndModified = false;
        for (let i = 0; i < userMessageContent.length; i++) {
          if (userMessageContent[i].text) {
            newTextForUserMessageContent = (userMessageContent[i].text || "") + suffix;
            userMessageContent[i].text = newTextForUserMessageContent;
            textPartFoundAndModified = true;
            break;
          }
        }
        if (!textPartFoundAndModified) { // If no text part, add one
            newTextForUserMessageContent = suffix;
            userMessageContent.push({text: newTextForUserMessageContent});
        }

        winstonLogger.info(`[CallbackSim] Executing beforeModel: ADD_SUFFIX_ABC_TO_PROMPT. Prompt modified.`, { agentId, flowName });
        chatEvents.push({
          id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
          callbackType: 'beforeModel', callbackAction: 'MODIFIED',
          eventTitle: `BeforeModel: ${beforeModelLogic}`,
          eventDetails: `Prompt (user message part) modified. Suffix "${suffix}" added.`,
          originalData: `Original User Message (part for LLM): "${originalUserMessageForEvent.substring(0,100)}..."`,
          modifiedData: `Modified User Message (part for LLM): "${newTextForUserMessageContent.substring(0,100)}..."`
        });
      } else {
        winstonLogger.info(`[CallbackSim] beforeModel logic "${beforeModelLogic}" is enabled but not a recognized simulation.`, { agentId, flowName });
        chatEvents.push({
          id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
          callbackType: 'beforeModel', callbackAction: 'UNRECOGNIZED_LOGIC',
          eventTitle: `BeforeModel: ${beforeModelLogic}`,
          eventDetails: `Logic "${beforeModelLogic}" enabled but not a recognized simulation.`
        });
      }
    }

    if (input.fileDataUri) {
      userMessageContent.push({
        media: {
          url: input.fileDataUri,
          contentType: 'auto'
        }
      });
    }
    messages.push({ role: 'user', content: userMessageContent });

    // Dynamically prepare tools for the current agent based on agentToolsDetails
    const genkitTools: AppTool[] = [];
    if (input.agentToolsDetails && input.agentToolsDetails.length > 0) {
      input.agentToolsDetails.forEach(toolDetail => {
        if (toolDetail.enabled) {
          const toolObj = allAvailableTools[toolDetail.id];
          if (toolObj) {
            // Todas as ferramentas já são instâncias de AppTool
            genkitTools.push(toolObj);
          }
        }
      });
    }

    const request: GenerateRequest = {
      messages: messages,
      config: {
        temperature: input.temperature,
        topK: input.topK,
        topP: input.topP,
        maxOutputTokens: input.maxOutputTokens,
        stopSequences: input.stopSequences
      },
      tools: genkitTools.length > 0 ? genkitTools.map(tool => ({
        name: tool.name,
        description: tool.description || '',
        inputSchema: tool.inputSchema ? tool.inputSchema : null,
        outputSchema: null,
        metadata: tool.metadata
      })) : undefined, // Only pass tools if there are any
    };
    // Loop for handling tool requests and responses
    let finalOutputText = ''; // Will store accumulated text from LLM
    let executedToolRequests: ChatToolRequest[] = [];
    let executedToolResults: ToolExecutionResult[] = []; // Updated type
    let currentMessages = [...messages]; // Start with the initial set of messages

    const MAX_TOOL_ITERATIONS = 5; // Prevent infinite loops

    // Guardrail: Before Model Callback Simulation (Existing)
    // This should ideally run on the potentially modified prompt by the simulated callback.
    // For now, placing the new callback simulation before this guardrail.
    // The `currentMessages` used by the guardrail will include modifications if any.
    let fullPromptTextForGuardrailCheck = "";
    // Rebuild `currentMessages` to include the user message with potential modifications
    const tempMessagesForGuardrail = [...messages]; // Start with system and history
    tempMessagesForGuardrail.push({ role: 'user', content: userMessageContent }); // Add potentially modified user message

    tempMessagesForGuardrail.forEach(msg => {
      msg.content.forEach(part => {
        if (part.text) {
          fullPromptTextForGuardrailCheck += part.text.toLowerCase() + " ";
        }
      });
    });

    for (const keyword of SENSITIVE_KEYWORDS) {
      if (fullPromptTextForGuardrailCheck.includes(keyword.toLowerCase())) {
        const errorMessage = `Guardrail ativado: Prompt bloqueado devido a conteúdo potencialmente sensível (palavra-chave: "${keyword}").`;
        winstonLogger.warn(`Guardrail (Model Prompt) triggered for Agent ${agentId}: ${errorMessage}`);
        // Ensure chatEvents is defined here if this is the first push
        // const chatEventsForGuardrail = chatEvents || [];
        chatEvents.push({
          id: `evt-${Date.now()}-guardrail-prompt`,
          timestamp: new Date(),
          eventType: 'AGENT_CONTROL',
          eventTitle: 'Guardrail: Prompt Bloqueado',
          eventDetails: errorMessage,
        });
        return { error: errorMessage, chatEvents };
      }
    }

    for (let iteration = 0; iteration < MAX_TOOL_ITERATIONS; iteration++) {
      // Ensure currentMessages for ai.generate() includes the latest user message (potentially modified)
      // and any tool responses from previous iterations.
      // If it's the first iteration, currentMessages should be system + history + user.
      // If it's a subsequent iteration, it's system + history + user + tool_responses...
      let messagesForThisIteration = [];
      if (iteration === 0) {
        messagesForThisIteration = [...messages, { role: 'user', content: userMessageContent }];
      } else {
        messagesForThisIteration = [...currentMessages]; // currentMessages would have been updated with tool responses
      }

      const llmResponse = await ai.generate({
        ...request,
        messages: messagesForThisIteration,
      });

      const choice = llmResponse.candidates[0];
      if (!choice || !choice.message || !choice.message.content) {
        finalOutputText = (choice?.finishReason === 'stop' && finalOutputText) ? finalOutputText : 'No response or empty content from model.';
        break;
      }

      // Clear finalOutputText at the beginning of processing a new LLM response in the loop,
      // unless we intend to accumulate text across multiple LLM calls that don't involve tools (which is not typical for this loop structure).
      // For this loop, each `ai.generate` is either a direct reply or a tool request.
      // If it's a direct reply (finishReason === 'stop'), finalOutputText will be built here.
      // If it's a tool request, finalOutputText from this iteration might be partial or empty.
      // The current accumulation `finalOutputText += part.text` assumes that text and tool requests can be interleaved.
      // Let's refine: only accumulate if it's the last iteration or no tool requests.

      const contentParts = choice.message.content;
      let hasToolRequestInThisResponse = false;
      let textFromThisResponse = "";

      for (const part of contentParts) {
        if (part.text) {
          textFromThisResponse += part.text;
        }
        if (part.toolRequest) {
          hasToolRequestInThisResponse = true;
          executedToolRequests.push(part.toolRequest); // Store for output
          // The actual tool execution will happen outside this loop based on these requests
          // For simplicity in this example, we'll assume Genkit's `generate` handles the tool execution
          // if the tool is defined and its `func` is called by Genkit internally.
          // If Genkit `generate` doesn't auto-execute and just returns requests,
          // then explicit tool execution logic would be needed here.
          // However, standard Genkit flow with tools in `generateOptions` implies Genkit handles this.
        }
      }

      if (!hasToolRequest || choice.finishReason === 'stop') {
        // If no tool requests in this response, or if LLM decided to stop, then we are done.
        break; 
      }

      // If there were tool requests, Genkit's `generate` (when tools are provided)
      // should ideally return tool responses if it executed them.
      // If `generate` only returns requests, we'd need to simulate or call tools here.
      // For this example, we'll assume `generate` returns responses if tools were called. (This assumption is being worked through)

      // Logic for handling tool responses and continuing the loop:
      // Add the LLM's message (that might contain tool_request) to currentMessages
      currentMessages = [...messagesForThisIteration, choice.message];


      if (!hasToolRequestInThisResponse) {
        finalOutputText = textFromThisResponse; // This is the final text response from LLM

        // Simulate afterModel callback
        const { logic: afterModelLogic, enabled: afterModelEnabled } = getCallbackConfig('afterModel');
        if (afterModelEnabled && afterModelLogic && finalOutputText) { // finalOutputText here is the complete model response if no tools were called
          winstonLogger.info(`[CallbackSim] Processing afterModel: "${afterModelLogic}" on final LLM response.`, { agentId, flowName });
          const originalResponseForEvent = finalOutputText;
          let actionDescription = `Logic "${afterModelLogic}" processed.`;
          let eventAction: string = 'PROCESSED';

          if (afterModelLogic === "REPLACE_BAD_WORD_WITH_GOOD_WORD") {
            finalOutputText = finalOutputText.replace(/bad/gi, 'good');
            if (originalResponseForEvent !== finalOutputText) {
              winstonLogger.info(`[CallbackSim] Executing afterModel: REPLACE_BAD_WORD_WITH_GOOD_WORD. Response modified.`, { agentId, flowName });
              actionDescription = `Replaced "bad" with "good" in response.`;
              eventAction = 'MODIFIED';
            } else {
              actionDescription = `No "bad" words found to replace.`;
              eventAction = 'NO_CHANGE';
            }
          } else if (afterModelLogic === "LOG_MODEL_RESPONSE") {
            winstonLogger.info(`[CallbackSim] Executing afterModel: LOG_MODEL_RESPONSE. Final Response: ${finalOutputText}`, { agentId, flowName });
            actionDescription = `Logged final model response.`;
            eventAction = 'LOGGED';
          } else {
            winstonLogger.info(`[CallbackSim] afterModel logic "${afterModelLogic}" is enabled but not a recognized simulation.`, { agentId, flowName });
            actionDescription = `Logic "${afterModelLogic}" is enabled but not a recognized simulation.`;
            eventAction = 'UNRECOGNIZED_LOGIC';
          }
          chatEvents.push({
            id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
            callbackType: 'afterModel', callbackAction: eventAction,
            eventTitle: `AfterModel: ${afterModelLogic}`, eventDetails: actionDescription,
            originalData: eventAction === 'MODIFIED' ? `Original: "${originalResponseForEvent.substring(0,100)}..."` : undefined,
            modifiedData: eventAction === 'MODIFIED' ? `Modified: "${finalOutputText.substring(0,100)}..."` : undefined,
          });
        }
        break; // No tool requests, so we are done with the loop.
      } else { // Branch where tool requests are present
        let potentiallyModifiedTextFromThisResponse = textFromThisResponse;
        const { logic: afterModelLogic, enabled: afterModelEnabled } = getCallbackConfig('afterModel');
        if (afterModelEnabled && afterModelLogic && potentiallyModifiedTextFromThisResponse) {
          winstonLogger.info(`[CallbackSim] Processing afterModel: "${afterModelLogic}" on partial LLM response text.`, { agentId, flowName });
          const originalPartialResponseForEvent = potentiallyModifiedTextFromThisResponse;
          let actionDescription = `Logic "${afterModelLogic}" processed on partial text.`;
          let eventAction: string = 'PROCESSED_PARTIAL';

          if (afterModelLogic === "REPLACE_BAD_WORD_WITH_GOOD_WORD") {
            potentiallyModifiedTextFromThisResponse = potentiallyModifiedTextFromThisResponse.replace(/bad/gi, 'good');
            if (originalPartialResponseForEvent !== potentiallyModifiedTextFromThisResponse) {
              winstonLogger.info(`[CallbackSim] Executing afterModel: REPLACE_BAD_WORD_WITH_GOOD_WORD. Partial response text modified.`, { agentId, flowName });
              actionDescription = `Replaced "bad" with "good" in partial response text.`;
              eventAction = 'MODIFIED_PARTIAL';
            } else {
              actionDescription = `No "bad" words found to replace in partial text.`;
              eventAction = 'NO_CHANGE_PARTIAL';
            }
          } else if (afterModelLogic === "LOG_MODEL_RESPONSE") {
            winstonLogger.info(`[CallbackSim] Executing afterModel: LOG_MODEL_RESPONSE. Partial Response text: ${potentiallyModifiedTextFromThisResponse}`, { agentId, flowName });
            actionDescription = `Logged partial model response text.`;
            eventAction = 'LOGGED_PARTIAL';
          } else {
            winstonLogger.info(`[CallbackSim] afterModel logic "${afterModelLogic}" (on partial text) is enabled but not a recognized simulation.`, { agentId, flowName });
            actionDescription = `Logic "${afterModelLogic}" on partial text is enabled but not a recognized simulation.`;
            eventAction = 'UNRECOGNIZED_LOGIC_PARTIAL';
          }
          chatEvents.push({
            id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
            callbackType: 'afterModel', callbackAction: eventAction,
            eventTitle: `AfterModel (Partial): ${afterModelLogic}`, eventDetails: actionDescription,
            originalData: eventAction === 'MODIFIED_PARTIAL' ? `Original: "${originalPartialResponseForEvent.substring(0,100)}..."` : undefined,
            modifiedData: eventAction === 'MODIFIED_PARTIAL' ? `Modified: "${potentiallyModifiedTextFromThisResponse.substring(0,100)}..."` : undefined,
          });
        }
        finalOutputText += potentiallyModifiedTextFromThisResponse; // Accumulate (potentially modified) partial text
      }

      const toolResponsePartsForNextIteration: ToolResponsePart[] = [];
      const toolRequestsFromThisResponse = contentParts.filter(p => p.toolRequest).map(p => p.toolRequest as ToolRequest);
      // executedToolRequests.push(...toolRequestsFromThisResponse); // Already pushed above if we want all attempts

      for (const toolRequest of toolRequestsFromThisResponse) {
        let toolExecutionFailed = false;
        let resultOutput: any;
        let errorMessage: string | undefined;

        // Create TOOL_CALL_PENDING event
        const pendingEventId = `evt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        chatEvents.push({
          id: pendingEventId,
          timestamp: new Date(),
          eventType: 'TOOL_CALL_PENDING',
          toolName: toolRequest.name,
          eventTitle: `Chamando ferramenta ${toolRequest.name}...`,
          eventDetails: JSON.stringify(toolRequest.input)
        });

        try {
          // Simulate beforeTool callback
          const { logic: beforeToolLogic, enabled: beforeToolEnabled } = getCallbackConfig('beforeTool');
          let modifiedToolInput = toolRequest.input; // Start with original input

          if (beforeToolEnabled && beforeToolLogic) {
            winstonLogger.info(`[CallbackSim] Processing beforeTool for "${toolRequest.name}": "${beforeToolLogic}"`, { agentId, flowName });
            if (beforeToolLogic.startsWith("BLOCK_TOOL_") && toolRequest.name.toUpperCase() === beforeToolLogic.substring("BLOCK_TOOL_".length).toUpperCase()) {
              winstonLogger.warn(`[CallbackSim] Executing beforeTool: ${beforeToolLogic}. Blocking tool ${toolRequest.name}.`, { agentId, flowName });
              toolExecutionFailed = true;
              errorMessage = `Execution of tool ${toolRequest.name} blocked by beforeTool callback.`;
              resultOutput = { error: errorMessage, code: 'CALLBACK_BLOCKED_TOOL_EXECUTION' };
              chatEvents.push({
                id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                toolName: toolRequest.name, callbackType: 'beforeTool', callbackAction: 'BLOCKED',
                eventTitle: `BeforeTool: ${beforeToolLogic} for ${toolRequest.name}`,
                eventDetails: `Tool execution blocked. Input: ${JSON.stringify(modifiedToolInput).substring(0,100)}...`
              });
            } else if (beforeToolLogic === "ADD_TOOL_INPUT_PREFIX") {
              const originalInputForEvent = JSON.stringify(modifiedToolInput);
              if (typeof modifiedToolInput === 'object' && modifiedToolInput !== null) {
                const prefix = "simulatedPrefix_";
                const newModifiedInput: Record<string, any> = {};
                Object.keys(modifiedToolInput).forEach(key => { // Iterate only over own properties
                    newModifiedInput[key] = prefix + (modifiedToolInput as Record<string,any>)[key];
                });
                modifiedToolInput = newModifiedInput;
                winstonLogger.info(`[CallbackSim] Executing beforeTool: ADD_TOOL_INPUT_PREFIX for "${toolRequest.name}". Input modified.`, { agentId, flowName });
                chatEvents.push({
                  id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                  toolName: toolRequest.name, callbackType: 'beforeTool', callbackAction: 'MODIFIED',
                  eventTitle: `BeforeTool: ${beforeToolLogic} for ${toolRequest.name}`,
                  eventDetails: `Tool input modified with prefix "${prefix}".`,
                  originalData: `Original input: ${originalInputForEvent.substring(0,100)}...`,
                  modifiedData: `Modified input: ${JSON.stringify(modifiedToolInput).substring(0,100)}...`
                });
              } else {
                winstonLogger.warn(`[CallbackSim] beforeTool: ADD_TOOL_INPUT_PREFIX for "${toolRequest.name}" - input is not an object, skipping modification.`, { agentId, flowName });
                 chatEvents.push({
                  id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                  toolName: toolRequest.name, callbackType: 'beforeTool', callbackAction: 'NO_CHANGE',
                  eventTitle: `BeforeTool: ${beforeToolLogic} for ${toolRequest.name}`,
                  eventDetails: `Input was not an object, skipping modification.`
                });
              }
            } else {
              winstonLogger.info(`[CallbackSim] beforeTool logic "${beforeToolLogic}" for tool "${toolRequest.name}" is enabled but not a recognized simulation.`, { agentId, flowName });
              chatEvents.push({
                id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                toolName: toolRequest.name, callbackType: 'beforeTool', callbackAction: 'UNRECOGNIZED_LOGIC',
                eventTitle: `BeforeTool: ${beforeToolLogic} for ${toolRequest.name}`,
                eventDetails: `Logic "${beforeToolLogic}" for tool "${toolRequest.name}" is enabled but not a recognized simulation.`
              });
            }
          }

          if (toolExecutionFailed) { // If callback blocked execution
            executedToolResults.push({ name: toolRequest.name, input: modifiedToolInput as Record<string, unknown>, errorDetails: { message: errorMessage!, code: (resultOutput as any).code }, status: 'error', ref: toolRequest.ref });
            // The chatEvent for TOOL_ERROR is pushed below, but we could add a specific one here if the structure for TOOL_ERROR is not sufficient
            // For now, relying on the existing TOOL_ERROR event push for callback-blocked tools.
            toolResponsePartsForNextIteration.push({ toolRequest, output: resultOutput });
            continue; // Skip to next toolRequest
          }

          const toolToRun = genkitTools.find(t => t.name === toolRequest.name) as AppTool | undefined;

          if (!toolToRun) {
            toolExecutionFailed = true;
            errorMessage = `Ferramenta ${toolRequest.name} não encontrada`;
            resultOutput = { error: errorMessage, code: 'TOOL_NOT_FOUND' };
            executedToolResults.push({
              name: toolRequest.name,
              input: toolRequest.input as Record<string, unknown>,
              errorDetails: { message: errorMessage, code: 'TOOL_NOT_FOUND' },
              status: 'error',
              ref: toolRequest.ref,
            });
            chatEvents.push({
              id: `evt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
              timestamp: new Date(),
              eventType: 'TOOL_ERROR',
              toolName: toolRequest.name,
              eventTitle: `Erro: Ferramenta ${toolRequest.name} não encontrada`,
              eventDetails: errorMessage,
            });
            toolResponseParts.push({ toolRequest, output: resultOutput });
            continue;
          }

          let validatedInput = toolRequest.input;
          if (toolToRun.inputSchema) {
            const validation = toolToRun.inputSchema.safeParse(toolRequest.input);
            if (!validation.success) {
              toolExecutionFailed = true;
              errorMessage = `Input inválido para ${toolRequest.name}: ${validation.error.issues.map(i => i.path.join('.') + ': ' + i.message).join(', ')}`;
              resultOutput = { error: errorMessage, code: 'INPUT_VALIDATION_ERROR', details: validation.error.issues };
              executedToolResults.push({
                name: toolRequest.name,
                input: toolRequest.input as Record<string, unknown>,
                errorDetails: { message: errorMessage, code: 'INPUT_VALIDATION_ERROR', details: validation.error.issues },
                status: 'error',
                ref: toolRequest.ref,
              });
              chatEvents.push({
                id: `evt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
                timestamp: new Date(),
                eventType: 'TOOL_ERROR',
                toolName: toolRequest.name,
                eventTitle: `Erro de validação para ${toolRequest.name}`,
                eventDetails: errorMessage,
              });
              toolResponseParts.push({ toolRequest, output: resultOutput });
              continue;
            }
            validatedInput = validation.data;
          }

          if (typeof toolToRun.func !== 'function') {
            toolExecutionFailed = true;
            errorMessage = `Ferramenta ${toolRequest.name} não possui função executável.`;
            resultOutput = { error: errorMessage, code: 'TOOL_NOT_EXECUTABLE' };
            executedToolResults.push({
              name: toolRequest.name,
              input: toolRequest.input as Record<string, unknown>,
              errorDetails: { message: errorMessage, code: 'TOOL_NOT_EXECUTABLE' },
              status: 'error',
              ref: toolRequest.ref,
            });
            chatEvents.push({
              id: `evt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
              timestamp: new Date(),
              eventType: 'TOOL_ERROR',
              toolName: toolRequest.name,
              eventTitle: `Erro: ${toolRequest.name} não executável`,
              eventDetails: errorMessage,
            });
            toolResponseParts.push({ toolRequest, output: resultOutput });
            continue;
          }

          // Guardrail: Before Tool Callback Simulation (Existing) - runs on potentially modified input
          const stringifiedToolInput = JSON.stringify(modifiedToolInput).toLowerCase();
          let toolBlockedByGuardrail = false;
          for (const keyword of SENSITIVE_KEYWORDS) {
            if (stringifiedToolInput.includes(keyword.toLowerCase())) {
              toolExecutionFailed = true;
              errorMessage = `Guardrail ativado: Execução de ferramenta '${toolRequest.name}' bloqueada devido a parâmetros potencialmente sensíveis (palavra-chave: "${keyword}").`;
              winstonLogger.warn(`Guardrail (Tool Input) triggered for Agent ${agentId}, Tool ${toolRequest.name}: ${errorMessage}`);
              resultOutput = { error: errorMessage, code: 'GUARDRAIL_TOOL_BLOCKED' };
              executedToolResults.push({ // Log the outcome
                name: toolRequest.name,
                input: modifiedToolInput as Record<string, unknown>, // Log modified input
                errorDetails: { message: errorMessage, code: 'GUARDRAIL_TOOL_BLOCKED' },
                status: 'error',
                ref: toolRequest.ref,
              });
              chatEvents.push({ // Add to chat events
                id: `evt-${Date.now()}-guardrail-tool-${toolRequest.name}`,
                timestamp: new Date(),
                eventType: 'TOOL_ERROR', // Or a new specific eventType like 'TOOL_GUARDRAIL_BLOCKED'
                toolName: toolRequest.name,
                eventTitle: `Guardrail: Ferramenta ${toolRequest.name} Bloqueada`,
                eventDetails: errorMessage,
              });
              toolResponseParts.push({ toolRequest, output: resultOutput });
              toolBlockedByGuardrail = true;
              break; // Keyword found, no need to check others
            }
          }

          if (toolBlockedByGuardrail) {
            continue; // Skip to the next tool request
          }

          // Execute the tool function with potentially modified input
          const toolRawOutput = await toolToRun.func(validatedInput); // validatedInput already incorporates modifiedToolInput if schema validation passed

          // Simulate afterTool callback
          let finalToolOutput = toolRawOutput;
          const { logic: afterToolLogic, enabled: afterToolEnabled } = getCallbackConfig('afterTool');
          if (afterToolEnabled && afterToolLogic && !toolExecutionFailed) { // Check !toolExecutionFailed again, although guardrail should prevent this point
            winstonLogger.info(`[CallbackSim] Processing afterTool for "${toolRequest.name}": "${afterToolLogic}"`, { agentId, flowName });
            if (afterToolLogic === "REPLACE_TOOL_OUTPUT_BAD_WITH_GOOD" && typeof finalToolOutput === 'string') {
              const originalToolOutputForEvent = finalToolOutput;
              finalToolOutput = finalToolOutput.replace(/bad/gi, 'good');
              if (originalToolOutputForEvent !== finalToolOutput) {
                winstonLogger.info(`[CallbackSim] Executing afterTool: REPLACE_TOOL_OUTPUT_BAD_WITH_GOOD for "${toolRequest.name}". Output modified.`, { agentId, flowName });
                chatEvents.push({
                  id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                  toolName: toolRequest.name, callbackType: 'afterTool', callbackAction: 'MODIFIED',
                  eventTitle: `AfterTool: ${afterToolLogic} for ${toolRequest.name}`, eventDetails: `Tool output modified.`,
                  originalData: `Original: "${originalToolOutputForEvent.substring(0,100)}..."`, modifiedData: `Modified: "${finalToolOutput.substring(0,100)}..."`
                });
              } else {
                 chatEvents.push({
                  id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                  toolName: toolRequest.name, callbackType: 'afterTool', callbackAction: 'NO_CHANGE',
                  eventTitle: `AfterTool: ${afterToolLogic} for ${toolRequest.name}`, eventDetails: `No "bad" words found to replace in tool output.`
                });
              }
            } else if (afterToolLogic === "LOG_TOOL_OUTPUT") {
              winstonLogger.info(`[CallbackSim] Executing afterTool: LOG_TOOL_OUTPUT for "${toolRequest.name}". Output: ${JSON.stringify(finalToolOutput)}`, { agentId, flowName });
              chatEvents.push({
                id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                toolName: toolRequest.name, callbackType: 'afterTool', callbackAction: 'LOGGED',
                eventTitle: `AfterTool: ${afterToolLogic} for ${toolRequest.name}`, eventDetails: `Logged tool output: ${JSON.stringify(finalToolOutput).substring(0,100)}...`
              });
            } else {
              winstonLogger.info(`[CallbackSim] afterTool logic "${afterToolLogic}" for tool "${toolRequest.name}" is enabled but not a recognized simulation.`, { agentId, flowName });
              chatEvents.push({
                id: `evt-cb-${Date.now()}`, timestamp: new Date(), eventType: 'CALLBACK_SIMULATION',
                toolName: toolRequest.name, callbackType: 'afterTool', callbackAction: 'UNRECOGNIZED_LOGIC',
                eventTitle: `AfterTool: ${afterToolLogic} for ${toolRequest.name}`,
                eventDetails: `Logic "${afterToolLogic}" for tool "${toolRequest.name}" is enabled but not a recognized simulation.`
              });
            }
          }

          // Process tool output (potentially modified by afterTool callback)
          if (finalToolOutput && typeof finalToolOutput === 'object' && 'errorDetails' in finalToolOutput && (finalToolOutput as any).errorDetails) {
            toolExecutionFailed = true;
            const toolErrorDetails = toolRawOutput.errorDetails as ErrorDetails;
            errorMessage = toolErrorDetails.message;
            executedToolResults.push({
              name: toolRequest.name,
              input: toolRequest.input as Record<string, unknown>,
              errorDetails: toolErrorDetails,
              status: 'error',
              ref: toolRequest.ref,
            });
            chatEvents.push({
              id: `evt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
              timestamp: new Date(),
              eventType: 'TOOL_ERROR',
              toolName: toolRequest.name,
              eventTitle: `Erro em ${toolRequest.name}: ${toolErrorDetails.code || 'Tool Reported Error'}`,
              eventDetails: toolErrorDetails.message + (toolErrorDetails.details ? ` Details: ${JSON.stringify(toolErrorDetails.details)}` : ''),
            });
            resultOutput = { error: toolErrorDetails.message, code: toolErrorDetails.code, details: toolErrorDetails.details };
            toolResponseParts.push({ toolRequest, output: resultOutput });
          } else {
            resultOutput = toolRawOutput;
            executedToolResults.push({
              name: toolRequest.name,
              input: toolRequest.input as Record<string, unknown>,
              output: resultOutput,
              status: 'success',
              ref: toolRequest.ref,
            });
            chatEvents.push({
              id: `evt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
              timestamp: new Date(),
              eventType: 'TOOL_CALL',
              toolName: toolRequest.name,
              eventTitle: `Ferramenta ${toolRequest.name} executada`,
              eventDetails: typeof resultOutput === 'string' ? resultOutput : JSON.stringify(resultOutput),
            });
            toolResponseParts.push({ toolRequest, output: resultOutput });
          }

        } catch (e: any) {
          toolExecutionFailed = true;
          errorMessage = e.message || 'Tool crashed during execution';
          const toolCrashError: ErrorDetails = {
            message: errorMessage,
            code: 'TOOL_CRASH',
            details: e.stack
          };
          resultOutput = { error: toolCrashError.message, code: toolCrashError.code };

          executedToolResults.push({
            name: toolRequest.name,
            input: toolRequest.input as Record<string, unknown>,
            errorDetails: toolCrashError,
            status: 'error',
            ref: toolRequest.ref,
          });
          chatEvents.push({
            id: `evt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            timestamp: new Date(),
            eventType: 'TOOL_ERROR',
            toolName: toolRequest.name,
            eventTitle: `Crash na ferramenta ${toolRequest.name}`,
            eventDetails: errorMessage + (e.stack ? ` Stack: ${e.stack}`: ''),
          });
          toolResponseParts.push({ toolRequest, output: resultOutput });
        }
      }

      // Add tool responses to messages for the next iteration
      // Only add if there were actual tool responses generated.
      if (toolResponseParts.length > 0) {
        currentMessages.push({
          role: 'tool',
          content: toolResponseParts.map(part => {
            // Ensure that the 'output' being stringified is appropriate,
            // especially if it's an error object.
            // For Genkit, the 'output' in ToolResponsePart is what's sent to the LLM.
            // If 'part.output' is an error, it should be represented in a way the LLM can understand.
            // For now, we assume JSON.stringify will handle it, but this might need refinement
            // based on how the LLM expects tool error messages.

          // This part constructs the message for the *next* LLM iteration.
          // The actual `tool_response` Part should be structured correctly.
          // Genkit expects `Part.toolResponse({ name: string, output: any, ref?: string })`
          // Let's try to use that, assuming `resultOutput` is the raw data for `output`.
          toolResponsePartsForNextIteration.push({
            toolRequest: toolRequest, // Keep original request for reference if needed, though Genkit uses 'ref'
            output: resultOutput, // This is the actual output to be sent back to the LLM
          });
        }
      }

      // Add tool responses to messages for the next iteration
      if (toolResponsePartsForNextIteration.length > 0) {
        currentMessages.push({
          role: 'tool',
          content: toolResponsePartsForNextIteration.map(tr => ({
            toolResponse: { // Using Genkit's defined Part.toolResponse structure
              name: tr.toolRequest.name,
              ref: tr.toolRequest.ref || '', // Ensure ref is a string
              output: tr.output,
            }
          }))
        });
      }
    } // End of for loop (MAX_TOOL_ITERATIONS)

  // const stream = llmResponse.stream ? llmResponse.stream() : null; // Stream handling would need rework with this loop, as llmResponse is from the last call
    // if (stream) { return { stream }; }

    // Simulated Safety Check on finalOutputText
    const SIMULATED_INSECURE_PHRASE = "resposta insegura simulada";
    if (finalOutputText.toLowerCase().includes(SIMULATED_INSECURE_PHRASE.toLowerCase())) {
      winstonLogger.warn(`Simulated Safety Alert triggered for Agent ${agentId}. Original response: "${finalOutputText}"`);
      finalOutputText = "Não posso responder a isso.";
      chatEvents.push({
        id: `evt-${Date.now()}-safety-alert`,
        timestamp: new Date(),
        eventType: 'AGENT_CONTROL',
        eventTitle: 'Alerta de Segurança Simulado',
        eventDetails: 'A resposta original foi substituída por uma mensagem padrão devido a preocupações de segurança simuladas.',
      });
    }

    let foundArtifact: GeneratedArtifactInfo | undefined = undefined;
    if (executedToolResults) { // Check if executedToolResults is not undefined
      for (const toolResult of executedToolResults) {
        if (toolResult.status === 'success' && toolResult.output && typeof toolResult.output === 'object') {
          const output = toolResult.output as any; // Using 'as any' for simplicity, consider defining a more specific type for tool outputs
          if (
            output.artifact &&
            typeof output.artifact.fileName === 'string' &&
            typeof output.artifact.fileType === 'string' &&
            (typeof output.artifact.fileDataUri === 'string' || typeof output.artifact.fileUrl === 'string')
          ) {
            foundArtifact = {
              fileName: output.artifact.fileName,
              fileType: output.artifact.fileType,
              fileDataUri: output.artifact.fileDataUri,
              fileUrl: output.artifact.fileUrl,
            };
            // Capture the first artifact found and break
            break;
          }
        }
      }
    }

    return {
      outputMessage: finalOutputText,
      toolRequests: executedToolRequests,
      toolResults: executedToolResults,
      chatEvents: chatEvents, // Add chatEvents to output
      generatedArtifact: foundArtifact, // Add generated artifact to output
      retrievedContextForDisplay: retrievedContextForDisplay, // Add RAG context
    };
  } catch (e: any) {
    winstonLogger.error(`Error in ${flowName} (Agent: ${agentId})`, {
      error: e instanceof Error ? { message: e.message, stack: e.stack, name: e.name } : String(e),
      agentId: agentId,
      flowName: flowName
    });
    // enhancedLogger.logError is good here if createLoggableFlow doesn't capture enough detail or if error is caught before re-throwing
    // For now, createLoggableFlow will handle the primary error logging.
    return { error: e.message || 'An unexpected error occurred', chatEvents, retrievedContextForDisplay }; // Also return chatEvents and context in case of early error
  }
}

// Wrap the internal function with createLoggableFlow
export const basicChatFlow = createLoggableFlow(
  "basicChatFlow", // Flow name
  {
    flow: basicChatFlowInternal, // The actual function to wrap
    inputTransformer: (input: BasicChatInput) => ({
      agentId: input.agentId || "unknown_agent",
      userMessageLength: input.userMessage.length,
      hasFileDataUri: !!input.fileDataUri,
      modelName: input.modelName,
      systemPromptLength: input.systemPrompt?.length,
      temperature: input.temperature,
      toolCount: input.agentToolsDetails?.filter(t => t.enabled).length || 0,
    }),
    outputTransformer: (output: BasicChatOutput) => ({
      hasOutputMessage: !!output.outputMessage,
      hasStream: !!output.stream,
      hasError: !!output.error,
      toolRequestCount: output.toolRequests?.length || 0,
      chatEventCount: output.chatEvents?.length || 0, // Added for logging
    }),
    agentIdExtractor: (input: BasicChatInput) => input.agentId || "unknown_agent"
  }
);

// Definir tipo extendido para MessageData
interface ChatMessageData extends MessageData {
  metadata?: Record<string, unknown>;
}
